\chapter{\textit{Expression Language} e \textit{TagLibs}}
\epigraph{``\textit{texto}''.}{autor}

\lettrine[lines=4, lhang=0.1, lraise=0, loversize=0.2, findent=0.1em]{\textcolor{corAzulTema}{N}}{ESTE} aaa.

Objetivos
Entender a sintaxe e o propósito da Expression Language.
Aprender a utilizar a Expression Language.
Entender o propósito das tags JSP.
Aprender a utilizar as tags JSP.
Aprender a utilizar as tags disponibilizadas na JSTL (Java Standard Template Library).


\section{Introdução}

Nesta aula iremos aprender duas funcionalidades muito importantes e úteis do mundo Java Web: EL (Expression Language) e as TagLibs. Essas duas funcionalidades nos ajudarão na tarefa de não misturar código Java nas nossas JSPs. Você se lembra quando falei que era possível inserir código Java dentro das JSPs, não lembra? Falei também que isso não deveria ser feito, pois deixa o código difícil de ler e de manter, além de fazer com que o trabalho do Web designer (que normalmente conhece mais HTML) se torne difícil, visto que ele teria que ter um bom conhecimento em Java e em como as JSPs funcionam. Usando a EL e as TagLibs, a manipulação de dados, provenientes dos Servlets, se torna muito mais fácil, pois utiliza uma sintaxe simples e fácil de entender, ajudando no trabalho de quem não conhece muito bem o funcionamento de aplicações Web em Java. Vamos começar?

\section{\textit{Expression Language} (EL)}

A EL é um recurso da especificação das JSPs que permite utilizarmos uma sintaxe especial para obter dados que gostaríamos de mostrar nas nossas páginas, além de permitir que façamos algumas outras coisas, como por exemplo, avaliar uma expressão lógica. Como de costume, iremos utilizar um projeto para aprendermos o recurso que estamos estudando. Vamos criar então o projeto, mas fique atento, pois agora iremos configurar algumas coisas no projeto que ainda não estávamos fazendo. 
Clique no menu “Arquivo” e escolha a opção “Novo Projeto...”. A janela do assistente para criação de projetos será aberta. Em “Categorias” escolha “Java Web”, em “Projetos” escolha “Aplicação Web” e clique em “Próximo”. Até agora, como você deve ter percebido, o processo que estamos realizando é o mesmo que fizemos nas semanas anteriores. A partir do segundo passo iremos fazer algumas modificações. Não se esqueça de fazê-las quando você estiver criando seus próximos projetos!
Preencha o campo “Nome do projeto” com “UsandoELeTagLibs” (sem as aspas). Marque a opção “Usar pasta dedicada para armazenar bibliotecas”. O NetBeans vai sugerir “.\\lib” como “Pasta de bibliotecas”. Deixe assim. No decorrer da aula, iremos inserir bibliotecas externas aos nossos projetos e fazendo esse passo que descrevi, nossas bibliotecas serão copiadas e referenciadas dentro do nosso projeto, permitindo que possamos abrir nosso projeto em qualquer instalação do NetBeans, mesmo que a versão usada não tenha as bibliotecas que utilizamos no nosso projeto. Clique em “Próximo” e siga os próximos passos da mesma forma que você tem feito.
Assim que o projeto for criado, iremos fazer uma modificação nas suas propriedades. Fique atento, pois como falei, a partir de agora, todos os nossos projetos serão modificados dessa forma. Clique com o botão direito no nó raiz do projeto e selecione a opção “Propriedades”. Veja a Figura 3.1.
Figura 3.1: Acessando as propriedades do projeto
 
Fonte: Print screen, NetBeans IDE 6.9.1
Ao fazer isso, o diálogo de propriedades do projeto será exibido. Procure em “Categorias” por “Executar” e clique nesse nó. Do lado direito do diálogo, serão exibidas as propriedades de execução do projeto, ou seja, como ele deve ser executado. Note que existe uma opção chamada “Implantar ao salvar”. Desmarque essa opção e clique em “OK”. As propriedades do projeto serão salvas e o diálogo será fechado. Ao desmarcar a opção “Implantar ao salvar”, estamos dizendo ao NetBeans que ele não deve implantar a aplicação no servidor (no caso o nosso container) toda vez que salvarmos algum arquivo. Isso faz com que o Tomcat não fique sobrecarregado durante o processo de desenvolvimento.
O fluxo do projeto que vamos desenvolver é representado na Figura 3.2.


Figura 3.2: Fluxo de execução do projeto
 
Fonte: do autor
Analisando a Figura 3.2, podemos perceber que teremos um formulário no index.jsp que terá seus dados tratados por um Servlet, que por sua vez irá fazer algum processamento e direcionar o resultado gerado para uma segunda JSP, chamada exibeDados.jsp.
Edite o index.jsp e insira um formulário. O meu ficou como mostrado naListagem 3.1. Copie o código para o seu index.jsp e teste. 
Note que nesse formulário temos algumas coisas novas. A primeira novidade é a tag style (linha 11). Usamos essa tag para criar estilos de formatação para o nosso documento. Tudo que usarmos de formatação como: alinhamento, cor de texto, etc., será definido usando estilos. Esses estilos são codificados usando as folhas de estilo (CSS – Cascading Style Sheets). A sintaxe é muito simples. As definições em CSS são chamadas de seletores. Sendo assim, a definição “.alinharDireita” (linha 12) indica que queremos criar um seletor que é uma classe de formatação (denotada pelo ponto (.)) que tem como nome “alinharDireita”. Todas as propriedades de formatação de um seletor são inseridas entre chaves. Note que usei a propriedade “text-align” com o valor de “right”. Ou seja, todas as tags que usarem a classe “.alinharDireita” vão ser formatadas para alinhar seu texto a direita.
Você já deve conhecer as tabelas do HTML não é mesmo? Note que organizei todo o formulário dentro de uma tabela e que a primeira coluna da tabela usa a classe “.alinharDireita”, que definimos lá no começo do arquivo. Verifique a linha 27 para ver um exemplo. Outra modificação que fiz foi em relação à action da tag form. Note que agora não estou mais colocando o caminho completo do Servlet (que vai ser mapeado como “/processaDadosProduto”), pois o Servlet é acessado no mesmo nível da nossa JSP (index.jsp). Esse tipo de caminho se chama “caminho relativo”, pois o mapeamento do Servlet (http://localhost:8084/UsandoELeTagLibs/processaDadosProduto) está no mesmo diretório em relação ao index.jsp (http://localhost:8084/UsandoELeTagLibs/index.jsp), sendo assim, não precisamos colocar o caminho completo, pois os dois recursos estão no mesmo diretório. Ao prosseguirmos com o conteúdo, irei ensinar uma técnica muito útil para não termos problema com os caminhos dos recursos.
A última novidade no nosso formulário é o uso da tag select que é usada para criar uma caixa de seleção (combo box). Veja que a propriedade “name” é definida na tag select e que dentro dessa tag existem três tags do tipo “option” (opção). A tag option é usada para criar um item da caixa de seleção. Cada option tem um valor associado que será enviado para o servidor com base na seleção feita. Por exemplo, se a opção “Unidade” for selecionada, será enviado o valor “un” na variável “unidade” (definida na propriedade “name” da tag select).

























Listagem 3.1: Formulário para envio de dados de um produto
 
Fonte: do autor
Com o formulário pronto, vamos criar uma classe que vai representar o nosso produto. Na pasta “Pacotes de código-fonte”, crie um novo pacote chamado “entidades” (sem as aspas). Nesse pacote, crie uma classe com o nome de “Produto” (sem as aspas). Nosso produto contém um código, uma descrição, uma unidade de medida e uma quantidade em estoque. Sendo assim, nossa classe também terá esses quatro campos, que devem ser implementados como membros privados. Você deve ter aprendido que quando criamos uma classe, devemos tornar seus campos privados e então criar métodos públicos para configurar e obter esses dados. Em Java, nós usamos um padrão chamado JavaBeans, que define algumas regras para se nomear os métodos que serão usados. Por exemplo, nosso produto terá um membro privado chamado “quantidade”, então teremos dois métodos públicos para acessar esse campo. O método setQuantidade (configureQuantidade) será usado para configurar a quantidade, enquanto o método getQuantidade (obtenhaQuantidade) será usado para obter o valor da quantidade. Uilizando essa abordagem de usar métodos para obter e configurar certos campos, nós obtemos o que chamamos de propriedades de uma determinada classe, pois independente de como os métodos são implementados, os usuários da classe só enxergam os métodos públicos. Lembra-se da propriedade do encapsulamento da programação orientada a objetos? Olha ela ai! Note que usamos os prefixos “set” e “get” para nomear métodos que respectivamente alteram e obtenham uma determinada propriedade do objeto. O uso desses prefixos, entre outros detalhes, é descrito no padrão JavaBeans.
Quantos detalhes hein? Veja na Listagem 3.2 como ficou a implementação da classe Produto.
Com a classe “Produto” implementada, agora podemos criar objetos do tipo “Produto” que vão conter os dados obtidos no formulário. Quem obtém e processa os dados enviados pelo formulário são os Servlets, então vamos criar um. Crie o pacote “servlets” para conter o Servlet que será criado. A classe do nosso Servlet, que deverá estar dentro do pacote recém-criado, terá o nome de “ProcessaDadosProdutoServlet” e deverá ser mapeada para “/processaDadosProduto” em “Padrão(ões) de URL”. A implementação do método processRequest do Servlet criado pode ser vista na Listagem 3.3.









Listagem 3.2: Implementação da classe Produto
 
Fonte: do autor






Listagem 3.3: Implementação do Servlet que cria um novo Produto
 
Fonte: do autor
Vamos às novidades apresentadas nesse Servlet. Entre as linhas 16 e 19 declaramos as variáveis que vão conter o valor dos campos do formulário, sendo que só obtemos os valores da descrição e da unidade de medida, pois o método getParameter retorna Strings.
Para as variáveis inteiras, nós precisamos converter o valor retornado de “código” e “quantidade” para inteiro. Você já deve conhecer esse tipo de conversão não é mesmo? Entre as linhas 21 e 33 usamos um try para verificar se a conversão de cada valor que deve ser inteiro foi bem sucedida. Caso você não conheça essa construção da linguagem, segue então uma explicação bem rápida. 
O bloco try (tentar) é usado na linguagem Java para englobar trechos de código que, ao serem executados, podem emitir certos tipos de “erros”. Esses “erros” são chamados de exceções. O método parseInt da classe Integer pode gerar um tipo desses erros quando é passado para ele uma String que não representa um número. Exemplo: imagine que no formulário dos dados do produto, você preencheu “um” ao invés de “1” no campo código. Esse valor (“um”) vai para o Servlet e quando o método parseInt tenta convertê-lo para um inteiro, ele verifica que “um” não representa um número, então ele dá um tipo de “grito”, que avisa quem está usando o método que alguma coisa errada aconteceu. Para ouvir esse grito, precisamos usar o bloco try e, logo em seguida, usar um catch, que é como se fosse um tipo de ouvido que só ouve um tipo de grito. O parseInt tentou converter “um”, não conseguiu e então gritou: “NumberFormatException!!!” Como temos um catch (ouvido) configurado para ouvir esse tipo de grito, quando o parseInt gritar, o catch vai entender o grito e vai fazer alguma coisa, que no caso é mostrar na saída “Erro ao converter o código.”. A mesma coisa é feita para o valor da quantidade. Resumindo – o try é usado para englobar uma ou mais linhas de código que potencialmente podem lançar algum tipo de exceção, sendo que a exceção que é lançada dentro do try deve ser capturada em um catch correspondente. Essa explicação é uma forma bem simples de entender o mecanismo de tratamento de exceções do Java, visto que existem muitos outros detalhes.
<Saiba mais:
Quer saber mais sobre tratamento de exceções? Veja os links a seguir:
http://imasters.com.br/artigo/11674/java/tratamento\_de\_excecoes\_na\_pratica/
http://www.inf.puc-rio.br/~java/progjava/protected/apostilas/transparencias/Excecoes.pdf
http://pt.wikipedia.org/wiki/Tratamento\_de\_exceções
>
Voltando ao Servlet... Na linha 36 da Listagem 3.3 é instanciado um novo Produto e este é atribuído a uma referência do tipo Produto chamada “prod”. Entre as linhas 37 e 40 são configuradas as propriedades do produto a partir dos dados obtidos através do formulário. Na linha 44, inserimos um atributo no request. Damos o nome de “produtoObtido” a esse tributo e configuramos  seu valor como sendo o produto que criamos e configuramos entre as linhas 36 e 40. Isso quer dizer que a próxima página ou Servlet que receber a requisição a partir deste Servlet, vai receber um objeto request com esse atributo, ou seja, o objeto “prod” (que é um produto) vai ficar acessível a outro componente da nossa aplicação! Confuso? Já você vai entender, fique calmo.
Na linha 49 criamos um RequestDispatcher, que é usado para direcionar o fluxo de execução do Servlet que está sendo executado para um outro recurso. No caso, esse recurso foi definido como “exibeDados.jsp”, uma página JSP que ainda vamos criar e que vai usar o atributo “produtoObtido” configurado no request para exibir os dados do produto.
Por fim, na linha 51, o método forward de “disp”, que é o nosso RequestDispatcher para o recurso “exibeDados.jsp”, é invocado, passando como parâmetro o request e o response do Servlet. Quando o método forward é invocado, o container direciona o fluxo para o recurso configurado e devolve o controle para o navegador caso o recurso deva ser exibido por ele. Uma JSP, por padrão, é usada para isso não é mesmo?
O que a página “exibeDados.jsp” vai fazer é pegar o atributo “produtoObtido” configurado no request e mostrar seus dados. Vamos criar então essa página. No NetBeans, procure pela pasta chamada “Páginas Web”. Clique com o botão direito nela, escolha “Novo” e procure por “JSP...”. Se não achar a opção JSP, você já deve saber como proceder não é mesmo? Preencha o campo “Nome do arquivo” com “exibeDados” (sem as aspas) e clique em “Finalizar”. O arquivo será criado e exibido no editor. Veja na Listagem 3.4 como ficou o código depois de ser editado.
















Listagem 3.4: Código da página exibeDados.jsp
 
Fonte: do autor
Copiou? Salvou? Faça um teste então! Execute o projeto, preencha o formulário e clique em “Enviar Dados”. O Servlet será invocado, processará os dados e vai redirecionar para a página “exibeDados.jsp”, que por sua vez vai mostrar os dados do produto. Legal não é? Mágica? Não! Vamos entender o que está acontecendo na página “exibeDados.jsp”. Veja as linhas 26, 30, 34 e 38. A construção \${...} é a EL! Usando a EL, nós podemos acessar valores que estão configurados no request e em outros “lugares” (escopos) também (que vamos aprender depois). No caso, o objeto requestScope da EL faz referência ao objeto request do Servlet que é gerado a partir da JSP. Lembre-se que uma JSP é convertida em um Servlet automaticamente pelo container!
Usar a expressão “\${requestScope.produtoObtido.codigo}” em EL quer dizer: obtenha o código, do objeto configurado no atributo “produtoObtido” do request. Lembre-se, nós configuramos no atributo “produtoObtido” no request (linha 44 da Listagem 3.3) um produto, que por sua vez tem um código (acessado pelo método getCodigo). O código Java equivalente a “\${requestScope.produtoObtido.codigo}” em um Servlet é mostrado na Listagem 3.5 nas duas linhas destacadas.
Listagem 3.5: Trecho de código correspondente à EL
 
Fonte: do autor
O propósito da EL é obter objetos que estão ativos nos diversos escopos da aplicação e poder obter suas propriedades, sem precisar lidar diretamente com código Java. Sei que esse foi um exemplo bem simples, mas tenho certeza que você deve ter entendido. Veja que o “codigo” usado na EL é relativo ao método getCodigo() e não ao membro privado da classe Produto chamado “codigo”. Essa mágica se dá pelo uso do padrão JavaBeans! Como exercício mental, analise as linhas 30, 34 e 38 e tente imaginar o que está acontecendo. Agora que já sabemos o que é a EL e como utilizá-la, vamos às tags JSP.


\section{Tags JSP}

Na especificação das JSPs, existem uma série de tags especiais que devem ser implementadas por quem implementa a especificação. Essas tags são nomeadas usando o prefixo “jsp”. Na verdade, nós quase não iremos utilizar essas tags e as que utilizarmos, explicarei no momento oportuno, mas para você ter uma ideia de como elas funcionam, crie uma página JSP chamada “testesTags” na pasta “Páginas Web” do projeto que estamos trabalhando. Veja na Listagem 3.6 o código que você deve copiar para o arquivo “testesTags.jsp”. 



Listagem 3.6: Exemplo das tags jsp:useBean jsp:setProperty
 
Fonte: do autor
Copie o código no seu arquivo, salve e entre no endereço http://localhost:8084/UsandoELeTagLibs/testesTags.jsp no seu navegador para testar a página. O que aconteceu? O produto criado foi exibido assim “4, Arroz, kg, 100” não foi? Vamos analisar o código no arquivo “testesTags.jsp”. Entre as linhas 14 e 17 definimos um comentário, que nas JSPs é delimitado entre “<\%--“ e “--\%>”. Esse comentário não pode ser visto no código-fonte da página HTML gerada! Nas linhas 18 e 19 usamos a tag jsp:useBean para criar um objeto com nome de “meuProduto” (configurado pela propriedade id), do tipo “entidades.Produto” (configurado pela propriedade class), que vai existir no escopo da página, ou seja, esse objeto só existe nesta página. Note que precisamos colocar o caminho completo da classe na propriedade class para informarmos qual o tipo de objetos que queremos instanciar. A partir da linha 22, usamos a tag jsp:setProperty para configurar as propriedades do objeto chamado “meuProduto” que foi criado usando a tag jsp:useBean. No exemplo da linha 22 e 23, referenciamos o objeto “meuProduto” e configuramos a propriedade “codigo” ((property=“codigo”) com o valor “4”. A instrução em Java equivalente a estas duas linhas é “meuProduto.setCodigo(4)”. A partir da linha 33, mostramos então os dados do objeto “meuProduto” que foi criado usando EL. Note que desta vez, usamos “pageScope” ao invés de “requestScope”, visto que o objeto existe apenas no escopo da página (veja na linha 19).
Da mesma forma que existem as tags JSP padrão, você pode criar suas próprias tags que podem ter comportamentos dos mais variados possíveis, entretanto nós não iremos aprender a fazer isso. Como é possível criar tags personalizadas, nós podemos usar conjuntos de tags que são implementadas por terceiros em nossos projetos. Um desses conjuntos é a JSTL (JavaServer Pages Standard Tag Library), que vamos aprender na próxima seção. Vamos lá então!


\section{\textit{JavaServer Pages Standard Tag Library} - JSTL}


A JSTL é uma biblioteca formada por um conjunto de tags (TagLib = Tag Library = Biblioteca de Tags) que visam apoiar o desenvolvedor na tarefa de construir suas páginas JSP, permitindo que várias coisas possam ser feitas sem o uso direto de código Java, por exemplo, iterar por uma lista de objetos, executar testes lógicos, formatar dados, entre muitos outros. Quando formos implementar nosso primeiro projeto na Aula 5, iremos utilizar muitos recursos da JSTL, mas por agora vamos aprender apenas como inseri-la no nosso projeto e fazer um pequeno exemplo.
Procure no seu projeto uma pasta chamada “Bibliotecas”, clique nela com o botão direito e escolha “Adicionar biblioteca...”. Ao clicar neste botão, o diálogo de inserção de bibliotecas aparecerá. Nele existirão três bibliotecas configuradas, entretanto o NetBeans vem com várias bibliotecas prontas para usar. Você se lembra que quando criamos esse projeto no início da aula (Seção 3.2), nós informamos que queríamos que as bibliotecas do nosso projeto fossem armazenadas dentro dele? Por isso que temos apenas três bibliotecas configuradas, que já foram importadas automaticamente para o nosso projeto. Se quisermos usar outra biblioteca que é disponibilizada no NetBeans, precisamos importá-la. No diálogo que está aberto, clique no botão “Importar...”. Será aberto outro diálogo com as bibliotecas disponíveis. Procure pela JSTL 1.1, clique nela para selecioná-la e então clique no botão “Importar Biblioteca”. Fazendo isso, o NetBeans vai fazer uma cópia dessa biblioteca para o nosso projeto, mas ainda não vai referencia-la para podermos usar, mostrando novamente o diálogo anterior. Agora, selecione a JSTL que já foi importada e clique no botão “Adicionar biblioteca”. Ao fazer isso, o NetBeans vai referenciar essa biblioteca para podermos usar no nosso projeto. Expanda a pasta das bibliotecas para ver que a JSTL 1.1 foi inserida (são dois arquivos .jar: standard,jar e jstl.jar).
Fazendo isso, podemos agora usar a JSTL. Vamos fazer um exemplo bem simples. Iremos criar um laço de repetição “for” usando tags da JSTL. Crie mais uma página JSP, com o nome de “testesJSTL”. O NetBeans vai abrir o arquivo quando este for criado. Vamos editá-lo? Copie então o código da Listagem 3.7.


Listagem 3.7: Exemplo de uso da JSTL
 Fonte: do autor
Copiou? Testou? Se tudo deu certo, você deve ter visto uma tabela zebrada (cor sim / cor não). Veja a Figura 3.3.
Figura 3.3: Visualização da página testesJSTL.jsp
 
Fonte: Print screen, Windows 7
Vamos analisar o código da Listagem 3.7. Talvez você tenha se assustado, mas não se preocupe, estou aqui para te explicar. Vamos começar pela primeira linha. Nessa linha, como em todos os JSPs que criamos até agora, usamos a diretiva “page”. As diretivas nos JSPs são delimitadas por “<\%@” e “\%>” e são usadas para realizar algumas configurações no Servlet que será gerado a partir do JSPs. A diretiva “page”, no nosso caso, é usada para configurar o response do Servlet, informando que ele vai conter um documento do tipo “text/html” (propriedade contentType) e que o encoding utilizado (como os caracteres são codificados) é o UTF-8 (propriedade pageEncoding). 
Na linha 2 utilizamos a diretiva “taglib”. Essa diretiva vai permitir que nós digamos qual TagLib queremos utilizar. A propriedade “uri” é usada para informarmos qual biblioteca de tags queremos utilizar. No nosso caso, queremos utilizar as funcionalidades principais da JSTL, que são chamadas de “core”. A URI para definir isso é a “http://java.sun.com/jsp/jstl/core”. A outra propriedade, “prefix” (prefixo), nos permite definir um prefixo para usar as tags. O prefixo padrão para a parte “core” da JSTL é “c”, mas podemos usar o prefixo que quisermos. Para manter o padrão, iremos usar o “c” mesmo. Assim, quando qualquer desenvolvedor Web que conheça a JSTL bater o olho no código e ver alguma tag que inicie com “c:” vai saber que a tag que está sendo utilizada faz parte do core da JSTL.
Entre as linhas 12 e 22 definimos duas classes CSS. Sendo que uma usaremos para colorir o fundo das linhas pares de uma tabela, enquanto a outra será usada para colorir o fundo das linhas ímpares. A propriedade usada em ambas as classes é a “background” (fundo), sendo que em cada uma usamos uma cor diferente usando a notação RGB (Reg Green Blue) em hexadecimal. Nas linhas 28 e 43, delimitamos uma tabela.
<Saiba mais:
Nunca ouviu falar de cores na notação em hexadecimal? Veja os links abaixo!
http://dematte.at/colorPicker/
http://colorschemedesigner.com/
http://pt.wikipedia.org/wiki/Tripleto\_hexadecimal
http://en.wikipedia.org/wiki/Web\_colors (em inglês)
>
Na linha 29, usamos a tag c:forEach (olhe o prefixo!), usada para iterar um determinado número de vezes ou sobre alguma lista de objetos. No nosso caso, queremos que o que está entre <c:forEach> e </c:forEach> seja executado dez vezes, pois definimos que a iteração deve iniciar em 1 (usando a propriedade “begin”) e ir até 10 (usando a propriedade “end”). Queremos também que o status da iteração seja armazenado na variável “i”, definida na propriedade “varStatus”. Então temos um for que vai executar dez vezes. Durante estas dez iterações, nós vamos construir nossa tabela, inserindo linhas nela com apenas uma coluna, mas queremos que as linhas pares sejam coloridas usando a classe linhaPar, enquanto que as linhas ímpares sejam coloridas usando a classe linhaImpar. Sabemos que todo número par tem resto igual à zero numa divisão por dois, correto? Então precisamos saber em qual iteração estamos, calcular o resto e verificar se é zero. Se for, cria uma linha da tabela usando a classe linhaPar, caso contrário, usa linhaImpar.
Para criar séries de testes lógicos como numa estrutura if / else if / else, nós usamos a tag c:choose (to choose = escolher) e dentro dela colocamos as condições que queremos testar usando a tag c:when que é equivalente aos if’s e else if’s e, por fim, se necessário, usamos a tag c:otherwise que é equivalente ao else. Vamos analisar o código então: entre as linhas 30 e 41, nós definimos nossa estrutura condicional usando a tag c:choose. Dentro dela, definimos na linha 31 uma tag c:when, que testa (propriedade “test”) se a divisão do atributo “count” da variável “i” por dois é igual a zero (par). Note o uso da EL e que podemos executar operações aritméticas dentro dela! Se o resultado for true, o número é par e o conteúdo deste c:when é gerado, ou seja, uma linha da tabela usando a classe linhaPar. Caso contrário, como não temos mais nenhum c:when, é gerado o código dentro do c:otherwise, que por sua vez também gera uma linha da tabela, só que usando a classe linhaImpar. Fique à vontade para mudar o conteúdo gerado dentro de cada linha, bem como as classes.
Viu como não é tão complicado? Na verdade é bem simples e fácil de usar, mas precisamos praticar para ficarmos craques. Depois dessa introdução à EL e a JSTL, nós já estamos quase prontos para começarmos o nosso primeiro projeto Web de verdade, mas ainda temos que formalizar algumas coisas que serão vistas na próxima aula. Novamente, não se esqueça de praticar o que fizemos até agora.  


\section{Resumo}

Nesta aula nós aprendemos a criar um formulário que teve seus dados tratados por um Servlet, que por sua vez redirecionou o fluxo da aplicação para outra página JSP, utilizada para mostrar os dados informados no formulário. Com isso, tivemos uma noção do que é a EL e como ela funciona. Depois aprendemos um pouco sobre as tags padrão da especificação dos JSPs e, por fim, aprendemos a inserir a JSTL em nosso projeto, além de fazermos alguns testes. Na próxima aula nós vamos dar uma paradinha com os JSPs e Servlets para podermos aprender como estruturar um projeto Web que trabalha com banco de dados. Tenho certeza que você vai gostar bastante.


\section{Exercícios}

1 – Explique, com suas palavras, qual a importância da EL.
2 – Justifique porque é melhor usar a JSTL ou qualquer outra TagLib ao invés de usar código Java diretamente nas JSPs.

\section{Projetos}

3 – Modifique o projeto feito na atividade 2 da Aula 2 para executar da mesma forma que o projeto criado nesta aula, ou seja, o formulário deve submeter os dados para um Servlet, que por sua vez deve criar e enviar um objeto através do request para um segundo JSP, que deve exibir ao usuário usando EL.
4 – Modifique o projeto feito na atividade 3 da Aula 2 para executar da mesma forma que o projeto criado nesta aula, ou seja, o formulário deve submeter os dados para um Servlet, que por sua vez deve criar e enviar um objeto através do request para um segundo JSP, que deve exibir ao usuário usando EL.
5 – Você já sabe que uma JSP na verdade é um Servlet não é mesmo? Será então que podemos definir na action de um formulário o endereço de um arquivo JSP ao invés de um Servlet? Crie um novo projeto Java Web, chamado “JSPTrataFormulario”, onde você deve ter um formulário no index.jsp que contenha dois campos: nome e idade. A action deste formulário deve apontar para um arquivo JSP chamado “exibeDadosForm.jsp” (sem as aspas). Nesse arquivo, você deve mostrar os dados recebidos do formulário do index.jsp usando EL. Dica: para acessar os parâmetros do request usando EL, usa-se \${param.nomeDoParametro}. Por exemplo, o parâmetro idade é acessado usando \${param.idade}.
6 – Crie um novo projeto Java Web, com o nome de “TabelaArbitraria” (sem as aspas e sem acentos), onde no index.jsp você deve ter uma formulário que pede ao usuário que seja digita a quantidade de linhas e de colunas que ele deseja que uma tabela seja gerada. Aponte a action deste formulário para outro arquivo JSP, chamado “montadorTabela.jsp”, que obtém os dados enviados pelo formulário do index.jsp usando EL e usa dois c:forEach aninhados para construir a tabela de dimensões arbitrárias. Monte a tabela somente se o tamanho de linhas e de colunas for maior que zero. Se não for, exiba uma mensagem ao usuário. Dica: para testar se duas condições são verdadeiras, ou seja, se param.colunas > 0 e param.linhas > 0, use o operador “and” da EL, enquanto o operador maior que é o “gt”. Ou seja, test=“\${(param.linhas gt 0) and (param.colunas gt 0)}”.
